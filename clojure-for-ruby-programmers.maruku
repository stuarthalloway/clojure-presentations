title: Clojure for Ruby Programmers

h1. Clojure for Ruby Programmers

* Stuart Halloway
* stu@thinkrelevance.com

<div style="font-size: 50%;">
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/us/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-nc-sa/3.0/us/88x31.png" /></a><br /><span xmlns:dc="http://purl.org/dc/elements/1.1/" href="http://purl.org/dc/dcmitype/Text" property="dc:title" rel="dc:type">Clojure for Ruby Programmers</span> by <a xmlns:cc="http://creativecommons.org/ns#" href="http://github.com/stuarthalloway/clojure-for-ruby-programmers" property="cc:attributionName" rel="cc:attributionURL">Stuart Halloway</a> is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/us/">Creative Commons Attribution-Noncommercial-Share Alike 3.0 United States License</a>.
</div>

h1. Why Clojure?

h1. Elegance

h1. Sequence Library

h1. Functional Programming

h1. Concurrency

h1. Java Interop

h1. Quick Start

h1. Interactive Environment 

<h2 class="ruby-concept">irb</h2>

<h2 class="clojure-concept">REPL</h2>

h1. Collections

<h2 class="ruby-concept">Enumerable</h2>

<h2 class="clojure-concept">Sequence</h2>

h1. select / filter

<pre>
<code class="ruby">
(1..10).select {|i| i % 2 == 0}
[2, 4, 6, 8, 10]
</code>
</pre>

<pre>
<code class="clojure">
(filter #(zero? (rem % 2)) (range 1 11))
-> (2 4 6 8 10)
</code>
</pre>

h1. map

<pre>
<code class="ruby">
(1..10).map {|i| i * 2}
=> [2, 4, 6, 8, 10, 12, 14, 16, 18, 20]
</code>
</pre>

<pre>
<code class="clojure">
(map #(* % 2) (range 1 11))
(2 4 6 8 10 12 14 16 18 20)
</code>
</pre>

h1. inject / reduce

<pre>
<code class="ruby">
(1..10).inject {|acc,i| acc + i}
=> 55
</code>
</pre>

<pre>
<code class="clojure">
(reduce + (range 1 11))
55
</code>
</pre>

h1. Higher-Order Functions

<pre>
<code class="ruby">
def make_adder(x)
  lambda {|i| x + i}
end
adder = make_adder(3)
adder[4]
=> 7
</code>
</pre>

<pre>
<code class="clojure">
(defn make-adder [x] (fn [i] (+ i x)))
#'user/make-adder
-> (def adder (make-adder 3))
#'user/adder
-> (adder 4)
7
</code>
</pre>

h1. Function Arguments

<h2 class="ruby-concept">Blocks</h2>

<h2 class="clojure-concept">Anonymous Functions</h2>

h1. Function Arguments Example

<pre>
<code class="ruby">
doubler = lambda {|i| i * 2}
doubler[5]
=> 10
</code>
</pre>

<pre>
<code class="clojure">
(let [doubler #(* % 2)] 
  (doubler 5)
)
10
-> (let [doubler (fn [i] (* i 2))]
  (doubler 5))
10
</code>
</pre>

h1. Data Structures

<table>
  <thead>
    <th colspan="2">Ruby</th>
    <th colspan="2">Clojure</th>
  </thead>
  <tr>
    <td>Array</td>
    <td>[1, 2, 3]</td>
    <td>vector</td>
    <td>[1 2 3]</td>
  </tr>
  <tr>
    <td>Hash</td>
    <td>{:name => "Ruby", :creator => "Matz"}</td>
    <td>map</td>
    <td>{:name "Clojure" :creator "Hickey"}</td>
  </tr>
  <tr>
    <td>Set</td>
    <td>Set[1,2,3]</td>
    <td>set</td>
    <td>#{1 2 3}</td>
  </tr>
</table>
  
h1. Names

<h2 class="ruby-concept">Symbols</h2>

<h2 class="clojure-concept">Symbols, Keywords</h2>

h1. IFn

h1. IFn Example: Maps

<pre>
<code class="clojure">
(def lang {:name "Clojure" :creator "Hickey"})
#'user/lang
user=> (get lang :name)
"Clojure"
user=> (lang :name)
"Clojure"
user=> (:name lang)
"Clojure"
</code>
</pre>

h1. Multiple Binding 

<h2 class="ruby-concept">Parallel Assignment</h2>

<h2 class="clojure-concept">Destructuring</h2>

h1. Multiple Binding Example 1

<pre>
<code class="ruby">
x, y, z = [1, 2, 3]
"x: #{x} y: #{y} z: #{z}"
=> "x: 1 y: 2 z: 3"
</code>
</pre>

<pre>
<code class="clojure">
(let [[x y z] [1 2 3]]
(format "x: %d y: %d z: %d" x y z))
"x: 1 y: 2 z: 3"
</code>
</pre>

h1. Multiple Binding Example 2

<pre>
<code class="clojure">
(let [[_ _ z :as point] [-14 11 21]]
(format "z: %d in %d dimensions" z (count point)))
"z: 21 in 3 dimensions"
</code>
</pre>

h1. Metadata

h1. Metdata on a Var

<pre>
<code class="clojure">
-> #'format
#'clojure.core/format
-> ^#'format
{:ns #<Namespace clojure.core>, 
 :name format, 
 :file "core.clj", 
 :line 3341, 
 :arglists ([fmt & args]), 
 :tag java.lang.String, 
 :doc "Formats a string using java.lang.String.format, see\
java.util.Formatter for format\n  string syntax"}
</code>
</pre>

h1. The Sequence Library

h1. What is a Sequence?

h1. first / rest / cons

<pre> 
<code class="clojure">
(first [1 2 3])
-> 1
(rest [1 2 3])
-> (2 3)
(cons "hello" [1 2 3])
-> ("hello" 1 2 3) 
</code> </pre>

h1. Sequence Library Examples

h1. Sequence Comprehension

h1. Sequence Comprehension Example

<pre> 
<code class="clojure">
(set! *print-length* 5)
5
(for [file "ABCDEFGH" rank (range 1 9)] (str file rank))
-> ("A1" "A2" "A3" "A4" "A5" ...) 
(for [i (iterate inc 0) :when (= 1 (rem i 2))] i)
-> (1 3 5 7 9 ...)
</code> 
</pre>

h1. Seq-ables

h1. Seq-able Examples

<pre> 
<code class="clojure">
(map #(.getName %) (.listFiles (java.io.File. ".")))
-> (".git" "build" "clojure-for-ruby-programmers.maruku" 
    "footer.html.erb" "gradient.svg.erb" ...) 
(line-seq (reader (java.io.File. "rakefile")))
-> ("desc \"build the slideshow\"" 
     "" 
     "task :slideshow do" 
     "  sh \"slideshow -v -o build clojure-for-ruby-programmers.maruku\"" 
     "end" ...)
</code> 
</pre>

h1. Functional Programming

h1. Pure Functions

h1. Referential Transparency

h1. Immutability

h1. Shared Structure

h1. Recurrences

h1. recur

h1. recur Example

<pre> 
<code class="clojure">
; from stactrace.clj, by Stuart Sierra
(defn print-cause-trace
  "Like print-stack-trace but prints chained exceptions (causes)."
  ([tr] (print-cause-trace tr nil))
  ([tr n]
     (print-stack-trace tr n)
     (when-let [cause (.getCause tr)]
       (print "Caused by: " )
       (recur cause n))))
</code> 
</pre>

h1. Laziness

h1. Lazy Example

<pre>
<code class="clojure">
(defn lazy-cons-fibo []
  ((fn fib [a b] 
     (lazy-cons a (fib b (+ a b)))) 
   0 1)) 
</code> 
</pre>

h1. Realization

h1. Memoization

h1. Concurrency

h1. Software Transactional Memory

h1. Unified Update Model

h1. Update Functions

<table>
  <thead>
    <th>Update Mechanism</th>
    <th>Refs</th>
    <th>Atoms</th>
    <th>Agents</th>
  </thead>
  <tr>
    <td>pure function application</td>
    <td><code>alter</code></td>
    <td><code>swap!</code></td>
    <td><code>send</code></td>
  </tr>
  <tr>
    <td>pure function (commutative)</td>
    <td><code>commute</code></td>
    <td>N/A</td>
    <td>N/A</td>
  </tr>
  <tr>
    <td>pure function (blocking)</td>
    <td>N/A</td>
    <td>N/A</td>
    <td><code>send-off</code></td>
  </tr>
  <tr>
    <td>setter</td>
    <td><code>ref-set</code></td>
    <td><code>reset!</code></td>
    <td>N/A</td>
  </tr>
</table>

h1. Example: Snake Game

h1. How do I do OO?

h1. What is OO?

* Encapsulation
* Polymorphism
* <span class="stricken">Inheritance</span>
* Reuse

h1. Macros

h1. Java Interop

h1. Interop Forms

h1. Threading

(Not the concurrency kind)

h1. Ruby Inspired Libraries

h1. Compojure

h1. Compojure Example: Servlet

<pre>
<code class="clojure">
(defservlet snippet-servlet
  (GET "/" 
     (new-snippet))

  (GET "/:id"
     (show-snippet (route :id)))

  (POST "/"
    (create-snippet (:body params))))	
</code> 
</pre>


h1. Compojure Example. Handlers

<pre>
<code class="clojure">
(defn new-snippet []
  (layout "Create a Snippet"
    (form-to [POST "/"]
      (text-area {:rows 20 :cols 73} "body")
      [:br]
      (submit-button "Save"))))

(defn create-snippet [body]
  (if-let [id (insert-snippet body)]
    (redirect-to (str "/" id))
    (redirect-to "/")))
</code> 
</pre>

h1. clj-record

<pre>
<code class="clojure">
(cljrec/init-model
  (has-many products)
  (validates name "empty!" #(not (empty? %)))
  (validates name "starts with whitespace!"
    #(not (re-find #"^\s" %)))
  (validates name "ends with whitespace!" 
    #(not (re-find #"\s$" %)))
  (validates grade "negative!" 
    #(or (nil? %) (>= % 0))))
</code> 
</pre>

h1. Clojure's Strengths

* Elegance Throughout
* Sequence Library
* Functional Programming
* Concurrency Model
* Macros
* Java Interop

h1. The Book

<a href="http://www.pragprog.com/titles/shcloj/programming-clojure">http://www.pragprog.com/titles/shcloj/programming-clojure</a>
